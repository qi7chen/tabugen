# Copyright (C) 2018-present qi7chen@github. All rights reserved.
# Distributed under the terms and conditions of the Apache License.
# See accompanying files LICENSE.

import os
import sys
from argparse import Namespace
import tabugen.predef as predef
import tabugen.lang as lang
import tabugen.version as version
import tabugen.util.helper as helper
from tabugen.util.tableutil import parse_kv_fields
from tabugen.structs import Struct, StructField, ArrayField
from tabugen.generator.csharp.gen_csv_load import CSharpCsvLoadGenerator


cs_template = """
// this interface define CSV data retrieving
public interface IDataFrame
{
    int ColumnCount { get; }
    int RowCount { get; }
    bool HasColumn(string name);
    string GetRowCell(string name, int index);
    string GetKeyField(string key);
}

"""

# C#代码生成器
class CSharpStructGenerator:
    TAB_SPACE = '    '

    @staticmethod
    def name():
        return "csharp"

    def __init__(self):
        self.load_gen = None

    def enable_gen_parse(self, name):
        if name == "csv":
            self.load_gen = CSharpCsvLoadGenerator()

    # 生成字段类型定义
    def gen_field_define(self, field: StructField, max_type_len: int, max_name_len: int, tabs: int,
                         json_snake_case: bool) -> str:
        typename = helper.pad_spaces(field.lang_type_name, max_type_len + 4)
        name = helper.pad_spaces(field.name_defval, max_name_len + 4)
        space = self.TAB_SPACE * tabs
        return '%spublic %s%s // %s\n' % (space, typename, name, field.comment)

    def gen_array_define(self, field: ArrayField, max_type_len: int, max_name_len: int, tabs: int) -> str:
        typename = helper.pad_spaces(field.lang_type_name, max_type_len + 4)
        name = helper.pad_spaces(field.name_defval, max_name_len + 4)
        text = '%spublic %s%s' % (self.TAB_SPACE * tabs, typename, name)
        if field.comment:
            text += ' // %s' % field.comment
        text += '\n'
        return text

    def gen_kv_fields_define(self, struct: Struct, args: Namespace) -> str:
        content = ''
        old_fields = struct.fields
        struct.fields = struct.kv_fields
        max_type_len = struct.max_field_lang_type_length()
        max_name_len = struct.max_field_lang_var_length()
        struct.fields = old_fields

        for field in struct.kv_fields:
            text = self.gen_field_define(field, max_type_len, max_name_len, 1, args.json_snake_case)
            content += text

        return content

    def gen_fields(self, struct: Struct, args: Namespace) -> str:
        content = ''
        fields = struct.fields
        for col, field in enumerate(fields):
            field.lang_type_name = lang.map_cs_type(field.origin_type_name)
            field.name_defval = lang.cs_type_var_with_default_value(field, field.lang_type_name)
        for array in struct.array_fields:
            array.lang_type_name = lang.map_cs_type(array.type_name)
            array.name_defval = lang.cs_type_var_with_default_value(array, array.lang_type_name)
            print(struct.name, 'array', array)

        max_type_len = struct.max_field_lang_type_length()
        max_name_len = struct.max_field_lang_var_length()

        for col, field in enumerate(fields):
            text = self.gen_field_define(field, max_type_len, max_name_len, 1, args.json_snake_case)
            content += text
        for array in struct.array_fields:
            text = self.gen_array_define(array, max_type_len, max_name_len, 1)
            content += text

        return content

    # 生成结构体定义
    def gen_struct(self, struct: Struct, args: Namespace):
        content = ''
        if struct.comment:
            content += '// %s, ' % struct.comment
        else:
            content += '// %s, ' % struct.name
        content += ' generated from %s\n' % struct.filepath

        def mapper(field):
            origin_type = field.origin_type_name
            typename = lang.map_cs_type(origin_type)
            return lang.cs_type_var_with_default_value(field, typename)

        content += 'public struct %s \n{\n' % struct.camel_case_name
        if struct.options[predef.PredefParseKVMode]:
            struct.kv_fields = parse_kv_fields(struct, args, lang.map_cs_type,mapper)
            content += self.gen_kv_fields_define(struct, args)
        else:
            content += self.gen_fields(struct, args)

        content += '\n\tpublic %s() {\n\t}\n\n' % struct.camel_case_name  # ctor

        if self.load_gen is not None:
            content += '\n'
            content += self.load_gen.generate(struct, args)

        content += '}\n\n'
        return content

    def generate(self, struct: Struct, args: Namespace):
        content = ''
        content += self.gen_struct(struct, args)
        return content

    def run(self, descriptors: list[Struct], filepath: str, args: Namespace):
        content = '// This file is auto-generated by Tabugen v%s, DO NOT EDIT!\n\n' % version.VER_STRING
        content += 'using System;\n'
        content += 'using System.Collections.Generic;\n'
        if args.json_snake_case:
            content += 'using System.Text.Json.Serialization;\n'

        if args.package is not None:
            content += '\nnamespace %s {\n' % args.package

        if self.load_gen:
            content += cs_template

        for struct in descriptors:
            content += self.generate(struct, args)

        if args.package is not None:
            content += '\n} // namespace %s \n' % args.package

        if not filepath.endswith('.cs'):
            filepath += '.cs'
        filename = os.path.abspath(filepath)
        helper.save_content_if_not_same(filename, content, 'utf-8')
        print('wrote C# source file to', filename)
